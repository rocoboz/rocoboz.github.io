<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gelişmiş Binance USDT-M Futures: AI Destekli Volatilite & Sinyal Tarayıcı Pro</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/4.4.1/chart.umd.min.js"></script>
  <style>
    :root {
      --bg-primary: #0a0e1a;
      --bg-secondary: #111827;
      --bg-tertiary: #1f2937;
      --bg-accent: #374151;
      --text-primary: #f9fafb;
      --text-secondary: #d1d5db;
      --text-muted: #9ca3af;
      --accent-blue: #3b82f6;
      --accent-cyan: #06b6d4;
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --purple: #8b5cf6;
      --border: rgba(75, 85, 99, 0.3);
      --shadow: rgba(0, 0, 0, 0.25);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: linear-gradient(135deg, var(--bg-primary) 0%, #0f172a 100%);
      color: var(--text-primary);
      line-height: 1.6;
      font-feature-settings: "cv02", "cv03", "cv04", "cv11";
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
    }
    /* Header Styles */
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(17, 24, 39, 0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border);
      padding: 16px 0;
    }
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 16px;
    }
    .header-title {
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .header-title h1 {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    .status-badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .badge {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }
    .badge.success {
      background: rgba(16, 185, 129, 0.1);
      border-color: var(--success);
      color: var(--success);
    }
    .badge.warning {
      background: rgba(245, 158, 11, 0.1);
      border-color: var(--warning);
      color: var(--warning);
    }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    /* Control Panel */
    .control-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      margin: 24px 0;
      box-shadow: 0 4px 6px var(--shadow);
    }
    .control-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 20px;
      margin-bottom: 24px;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .form-label {
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
    }
    .form-input {
      padding: 12px 16px;
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 8px;
      color: var(--text-primary);
      font-size: 14px;
      transition: all 0.2s ease;
    }
    .form-input:focus {
      outline: none;
      border-color: var(--accent-blue);
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
    }
    .button-group {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      flex-wrap: wrap;
    }
    .btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px 20px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      text-decoration: none;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-cyan));
      color: white;
    }
    .btn-primary:hover:not(:disabled) {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .btn-secondary {
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border: 1px solid var(--border);
    }
    .btn-secondary:hover:not(:disabled) {
      background: var(--bg-accent);
      color: var(--text-primary);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    /* Main Content Layout */
    .main-content {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 24px;
      margin-bottom: 24px;
    }
    /* Data Table */
    .data-table-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 6px var(--shadow);
    }
    .data-table {
      width: 100%;
      border-collapse: collapse;
    }
    .table-header {
      background: var(--bg-tertiary);
      border-bottom: 1px solid var(--border);
    }
    .table-header th {
      padding: 16px 12px;
      text-align: left;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .table-row {
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .table-row:hover {
      background: rgba(59, 130, 246, 0.05);
    }
    .table-row.selected {
      background: rgba(59, 130, 246, 0.1);
      border-color: var(--accent-blue);
    }
    .table-row td {
      padding: 12px;
      font-size: 14px;
      vertical-align: middle;
    }
    .symbol-cell {
      font-weight: 600;
      color: var(--text-primary);
    }
    .symbol-meta {
      font-size: 11px;
      color: var(--text-muted);
      margin-top: 2px;
    }
    /* Signal Tags */
    .signal-tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .signal-tag.long {
      background: rgba(16, 185, 129, 0.15);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.3);
    }
    .signal-tag.short {
      background: rgba(239, 68, 68, 0.15);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.3);
    }
    .signal-tag.neutral {
      background: rgba(156, 163, 175, 0.15);
      color: var(--text-muted);
      border: 1px solid rgba(156, 163, 175, 0.3);
    }
    .signal-tag.weak_long {
      background: rgba(16, 185, 129, 0.08);
      color: var(--success);
      border: 1px solid rgba(16, 185, 129, 0.2);
    }
    .signal-tag.weak_short {
      background: rgba(239, 68, 68, 0.08);
      color: var(--danger);
      border: 1px solid rgba(239, 68, 68, 0.2);
    }
    /* Chart Panel */
    .chart-panel {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 4px 6px var(--shadow);
      position: sticky;
      top: 100px;
      height: fit-content;
    }
    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    .chart-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-primary);
    }
    .chart-meta {
      font-size: 12px;
      color: var(--text-muted);
    }
    .chart-container {
      position: relative;
      height: 300px;
      margin-bottom: 20px;
    }
    .analysis-panel {
      background: var(--bg-tertiary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }
    .analysis-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 12px;
    }
    .analysis-content {
      font-size: 13px;
      line-height: 1.5;
      color: var(--text-muted);
    }
    /* Progress Bar */
    .progress-container {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 20px;
      margin: 20px 0;
    }
    .progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }
    .progress-bar {
      height: 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      overflow: hidden;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-blue), var(--accent-cyan));
      transition: width 0.3s ease;
      border-radius: 4px;
    }
    /* Responsive Design */
    @media (max-width: 1200px) {
      .main-content {
        grid-template-columns: 1fr;
      }
      .chart-panel {
        position: relative;
        top: unset;
      }
    }
    @media (max-width: 768px) {
      .container {
        padding: 0 12px;
      }
      .header-content {
        flex-direction: column;
        align-items: flex-start;
      }
      .control-grid {
        grid-template-columns: 1fr;
      }
      .button-group {
        justify-content: stretch;
      }
      .button-group .btn {
        flex: 1;
        justify-content: center;
      }
    }
    /* Scrollbar Styling */
    ::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--bg-tertiary);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb {
      background: var(--bg-accent);
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #6b7280;
    }
    /* Loading Animation */
    .loading {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-top: 2px solid var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    /* Utility Classes */
    .text-center { text-align: center; }
    .text-success { color: var(--success); }
    .text-danger { color: var(--danger); }
    .text-warning { color: var(--warning); }
    .font-mono { font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace; }
  </style>
</head>
<body>
  <div class="header">
    <div class="container">
      <div class="header-content">
        <div class="header-title">
          <div style="font-size: 28px;">⚡</div>
          <h1>Gelişmiş Binance USDT-M Futures AI Tarayıcı Pro</h1>
        </div>
        <div class="status-badges">
          <div class="badge success">
            <div class="status-dot"></div>
            <span>Canlı Veri</span>
          </div>
          <div class="badge" id="lastUpdateBadge">
            Son Güncelleme: <span id="lastUpdate">Henüz tarama yapılmadı</span>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="container">
    <div class="control-panel">
      <div class="control-grid">
        <div class="form-group">
          <label class="form-label">📊 Tarama Adedi</label>
          <input type="number" id="topN" class="form-input" value="100" min="10" max="500" />
        </div>
        <div class="form-group">
          <label class="form-label">⏱️ Zaman Dilimi</label>
          <select id="interval" class="form-input">
            <option value="15m">15 Dakika</option>
            <option value="1h" selected>1 Saat</option>
            <option value="4h">4 Saat</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">📈 Veri Uzunluğu</label>
          <input type="number" id="limit" class="form-input" value="300" min="100" max="1000" />
        </div>
        <div class="form-group">
          <label class="form-label">🔄 Otomatik Yenile (saniye)</label>
          <input type="number" id="refreshInterval" class="form-input" value="45" min="15" max="300" />
        </div>
        <div class="form-group">
          <label class="form-label">🎯 Minimum Sinyal Gücü</label>
          <select id="minSignalStrength" class="form-input">
            <option value="0">Tümü</option>
            <option value="1">Zayıf+</option>
            <option value="2" selected>Orta+</option>
            <option value="3">Güçlü+</option>
          </select>
        </div>
        <div class="form-group">
          <label class="form-label">💹 Minimum Volatilite (%)</label>
          <input type="number" id="minVolatility" class="form-input" value="2" min="0" max="50" step="0.5" />
        </div>
      </div>
      <div class="button-group">
        <button id="scanBtn" class="btn btn-primary">
          <span>🔍</span>
          <span>Gelişmiş Tarama Başlat</span>
        </button>
        <button id="stopBtn" class="btn btn-secondary">
          <span>⏹️</span>
          <span>Durdur</span>
        </button>
        <button id="exportBtn" class="btn btn-secondary">
          <span>📥</span>
          <span>CSV Dışa Aktar</span>
        </button>
        <button id="alertsBtn" class="btn btn-secondary">
          <span>🔔</span>
          <span>Alarm Ayarları</span>
        </button>
      </div>
    </div>
    <div class="progress-container" id="progressContainer" style="display: none;">
      <div class="progress-header">
        <span id="progressStatus">Hazırlanıyor...</span>
        <span id="progressPercent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
      </div>
    </div>
    <div class="main-content">
      <div class="data-table-container">
        <table class="data-table">
          <thead class="table-header">
            <tr>
              <th>Sembol</th>
              <th>Vol%</th>
              <th>Fiyat</th>
              <th>24s %</th>
              <th>RSI</th>
              <th>MACD</th>
              <th>BB</th>
              <th>Vol</th>
              <th>ATR%</th>
              <th>Fund%</th>
              <th>OI</th>
              <th>Sinyal</th>
              <th>Güç</th>
            </tr>
          </thead>
          <tbody id="dataTableBody">
            <tr>
              <td colspan="13" class="text-center" style="padding: 40px;">
                <div style="color: var(--text-muted);">
                  Tarama başlatmak için yukarıdaki "Gelişmiş Tarama Başlat" butonuna tıklayın
                </div>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
      <div class="chart-panel">
        <div class="chart-header">
          <div>
            <div class="chart-title" id="chartTitle">Parite Seçin</div>
            <div class="chart-meta" id="chartMeta">Grafiği görmek için soldan bir satır seçin</div>
          </div>
        </div>
        <div class="chart-container">
          <canvas id="priceChart"></canvas>
        </div>
        <div class="analysis-panel">
          <div class="analysis-title">📊 Teknik Analiz</div>
          <div class="analysis-content" id="analysisContent">
            Analiz için parite seçin...
          </div>
        </div>
        <div class="analysis-panel" style="margin-top: 12px;">
          <div class="analysis-title">🕯️ Mum Formasyonları</div>
          <div class="analysis-content" id="candlePatterns">
            Parite seçilmedi...
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // API Endpoints
    const BINANCE_API = 'https://fapi.binance.com';
    const API_ENDPOINTS = {
      exchangeInfo: `${BINANCE_API}/fapi/v1/exchangeInfo`,
      ticker24hr: `${BINANCE_API}/fapi/v1/ticker/24hr`,
      klines: `${BINANCE_API}/fapi/v1/klines`,
      premiumIndex: `${BINANCE_API}/fapi/v1/premiumIndex`,
      openInterest: `${BINANCE_API}/fapi/v1/openInterest`,
    };
    // Global State
    let scanInterval = null;
    let currentData = [];
    let priceChart = null;
    let selectedSymbol = null;
    let isScanning = false;
    // Utility Functions
    const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
    const fmt = (num, decimals = 2) => {
      if (num === null || num === undefined || isNaN(num)) return '—';
      return Number(num).toFixed(decimals);
    };
    // Technical Indicators
    const calculateEMA = (data, period) => {
      const multiplier = 2 / (period + 1);
      let ema = [];
      ema[0] = data[0];
      for (let i = 1; i < data.length; i++) {
        ema[i] = (data[i] * multiplier) + (ema[i - 1] * (1 - multiplier));
      }
      return ema;
    };
    const calculateSMA = (data, period) => {
      let sma = [];
      for (let i = 0; i < data.length; i++) {
        if (i < period - 1) {
          sma[i] = null;
        } else {
          let sum = 0;
          for (let j = i - period + 1; j <= i; j++) {
            sum += data[j];
          }
          sma[i] = sum / period;
        }
      }
      return sma;
    };
    const calculateRSI = (closes, period = 14) => {
      let gains = [];
      let losses = [];
      for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? Math.abs(change) : 0);
      }
      const avgGains = calculateSMA(gains, period);
      const avgLosses = calculateSMA(losses, period);
      let rsi = [null];
      for (let i = 0; i < avgGains.length; i++) {
        if (avgGains[i] !== null && avgLosses[i] !== null) {
          if (avgLosses[i] === 0) {
            rsi.push(100);
          } else {
            const rs = avgGains[i] / avgLosses[i];
            rsi.push(100 - (100 / (1 + rs)));
          }
        } else {
          rsi.push(null);
        }
      }
      return rsi;
    };
    const calculateMACD = (closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) => {
      const emaFast = calculateEMA(closes, fastPeriod);
      const emaSlow = calculateEMA(closes, slowPeriod);
      const macdLine = emaFast.map((fast, i) => fast - emaSlow[i]);
      const signalLine = calculateEMA(macdLine.slice(slowPeriod - 1), signalPeriod);
      // Pad signal line
      const paddedSignal = new Array(slowPeriod - 1).fill(null).concat(signalLine);
      const histogram = macdLine.map((macd, i) => {
        return paddedSignal[i] !== null ? macd - paddedSignal[i] : null;
      });
      return {
        macd: macdLine,
        signal: paddedSignal,
        histogram: histogram
      };
    };
    const calculateBollingerBands = (closes, period = 20, multiplier = 2) => {
      const sma = calculateSMA(closes, period);
      let upper = [];
      let lower = [];
      for (let i = 0; i < closes.length; i++) {
        if (i < period - 1) {
          upper[i] = null;
          lower[i] = null;
        } else {
          let sum = 0;
          for (let j = i - period + 1; j <= i; j++) {
            sum += Math.pow(closes[j] - sma[i], 2);
          }
          const stdDev = Math.sqrt(sum / period);
          upper[i] = sma[i] + (stdDev * multiplier);
          lower[i] = sma[i] - (stdDev * multiplier);
        }
      }
      return { upper, middle: sma, lower };
    };
    const calculateATR = (highs, lows, closes, period = 14) => {
      let trueRanges = [];
      // İlk true range için, önceki kapanışı kullanamadığımız için high - low kullanıyoruz
      trueRanges.push(highs[0] - lows[0]);
      
      for (let i = 1; i < closes.length; i++) {
        const tr1 = highs[i] - lows[i];
        const tr2 = Math.abs(highs[i] - closes[i - 1]);
        const tr3 = Math.abs(lows[i] - closes[i - 1]);
        trueRanges.push(Math.max(tr1, tr2, tr3));
      }
      
      // SMA'yı trueRanges üzerine doğrudan uyguluyoruz
      const atr = calculateSMA(trueRanges, period);
      
      // İlk period-1 değeri null olacak, bu doğru
      return atr;
    };
    // Stochastic Oscillator
    const calculateStochastic = (highs, lows, closes, kPeriod = 14, dPeriod = 3) => {
      let kValues = [];
      for (let i = 0; i < closes.length; i++) {
        if (i < kPeriod - 1) {
          kValues.push(null);
        } else {
          const highestHigh = Math.max(...highs.slice(i - kPeriod + 1, i + 1));
          const lowestLow = Math.min(...lows.slice(i - kPeriod + 1, i + 1));
          const k = ((closes[i] - lowestLow) / (highestHigh - lowestLow)) * 100;
          kValues.push(k);
        }
      }
      const dValues = calculateSMA(kValues, dPeriod);
      return { k: kValues, d: dValues };
    };
    // ADX (Average Directional Index)
    const calculateADX = (highs, lows, closes, period = 14) => {
      const atr = calculateATR(highs, lows, closes, period);
      let plusDM = [null];
      let minusDM = [null];
      for (let i = 1; i < highs.length; i++) {
        const upMove = highs[i] - highs[i - 1];
        const downMove = lows[i - 1] - lows[i];
        if (upMove > downMove && upMove > 0) {
          plusDM.push(upMove);
        } else {
          plusDM.push(0);
        }
        if (downMove > upMove && downMove > 0) {
          minusDM.push(downMove);
        } else {
          minusDM.push(0);
        }
      }
      const plusDI = plusDM.map((dm, i) => {
        if (i === 0 || dm === null || atr[i] === null || atr[i] === 0) return null;
        return (dm / atr[i]) * 100;
      });
      const minusDI = minusDM.map((dm, i) => {
        if (i === 0 || dm === null || atr[i] === null || atr[i] === 0) return null;
        return (dm / atr[i]) * 100;
      });
      let dx = [];
      for (let i = 0; i < plusDI.length; i++) {
        if (plusDI[i] === null || minusDI[i] === null) {
          dx.push(null);
        } else {
          const diSum = plusDI[i] + minusDI[i];
          dx.push(diSum === 0 ? 0 : (Math.abs(plusDI[i] - minusDI[i]) / diSum) * 100);
        }
      }
      const adx = calculateSMA(dx, period);
      return { plusDI, minusDI, adx };
    };
    // Ichimoku Cloud
    const calculateIchimoku = (highs, lows, closes) => {
      const conversionPeriod = 9;
      const basePeriod = 26;
      const spanPeriod = 52;
      const displacement = 26;
      const donchian = (data, period) => {
        let result = [];
        for (let i = 0; i < data.length; i++) {
          if (i < period - 1) {
            result.push(null);
          } else {
            const slice = data.slice(i - period + 1, i + 1);
            result.push((Math.max(...slice) + Math.min(...slice)) / 2);
          }
        }
        return result;
      };
      const conversionLine = donchian(
        highs.map((h, i) => (h + lows[i]) / 2),
        conversionPeriod
      );
      const baseLine = donchian(
        highs.map((h, i) => (h + lows[i]) / 2),
        basePeriod
      );
      let spanA = [];
      for (let i = 0; i < conversionLine.length; i++) {
        if (conversionLine[i] === null || baseLine[i] === null) {
          spanA.push(null);
        } else {
          spanA.push((conversionLine[i] + baseLine[i]) / 2);
        }
      }
      const spanB = [null, ...donchian(
        highs.map((h, i) => (h + lows[i]) / 2),
        spanPeriod
      ).slice(0, -1)];
      return {
        conversionLine,
        baseLine,
        spanA: [null, ...spanA.slice(0, -1)],
        spanB: [null, ...spanB.slice(0, -1)]
      };
    };
    // Candlestick Pattern Detection
    const detectCandlestickPatterns = (opens, highs, lows, closes, volume) => {
      const patterns = [];
      const len = closes.length;
      if (len < 3) return patterns;
      const current = len - 1;
      const prev = current - 1;
      const prev2 = current - 2;
      // Current candle data
      const o = opens[current];
      const h = highs[current];
      const l = lows[current];
      const c = closes[current];
      const body = Math.abs(c - o);
      const upperShadow = h - Math.max(o, c);
      const lowerShadow = Math.min(o, c) - l;
      const range = h - l;
      // Previous candle data
      const o1 = opens[prev];
      const h1 = highs[prev];
      const l1 = lows[prev];
      const c1 = closes[prev];
      const body1 = Math.abs(c1 - o1);
      // Pattern Detection
      // Doji
      if (body < range * 0.1 && range > 0) {
        if (upperShadow > body * 2 && lowerShadow > body * 2) {
          patterns.push('Long Legged Doji');
        } else if (upperShadow > body * 3) {
          patterns.push('Gravestone Doji');
        } else if (lowerShadow > body * 3) {
          patterns.push('Dragonfly Doji');
        } else {
          patterns.push('Doji');
        }
      }
      // Hammer & Hanging Man
      if (lowerShadow > body * 2 && upperShadow < body * 0.5) {
        if (c > o) {
          patterns.push('Hammer');
        } else {
          patterns.push('Hanging Man');
        }
      }
      // Inverted Hammer & Shooting Star
      if (upperShadow > body * 2 && lowerShadow < body * 0.5) {
        if (c > o) {
          patterns.push('Inverted Hammer');
        } else {
          patterns.push('Shooting Star');
        }
      }
      // Engulfing Patterns
      if (prev >= 0) {
        const bullishEngulfing = (
          c1 < o1 && // Previous red
          c > o && // Current green
          c > o1 && // Current close above previous open
          o < c1 && // Current open below previous close
          body > body1 // Current body larger
        );
        const bearishEngulfing = (
          c1 > o1 && // Previous green
          c < o && // Current red
          c < o1 && // Current close below previous open
          o > c1 && // Current open above previous close
          body > body1 // Current body larger
        );
        if (bullishEngulfing) patterns.push('Bullish Engulfing');
        if (bearishEngulfing) patterns.push('Bearish Engulfing');
      }
      // Morning Star & Evening Star (3-candle patterns)
      if (prev2 >= 0) {
        const o2 = opens[prev2];
        const c2 = closes[prev2];
        const body2 = Math.abs(c2 - o2);
        // Morning Star
        const morningStar = (
          c2 < o2 && // First candle red
          body1 < body2 * 0.3 && // Middle candle small
          c > o && // Third candle green
          c > (o2 + c2) / 2 // Third candle closes above midpoint of first
        );
        // Evening Star
        const eveningStar = (
          c2 > o2 && // First candle green
          body1 < body2 * 0.3 && // Middle candle small
          c < o && // Third candle red
          c < (o2 + c2) / 2 // Third candle closes below midpoint of first
        );
        if (morningStar) patterns.push('Morning Star');
        if (eveningStar) patterns.push('Evening Star');
      }
      return patterns;
    };
    // Advanced Signal Generation with Enhanced Confidence Calculation
    const generateAdvancedSignal = (data) => {
      const {
        rsi, macd, bb, atr, closes, volume, funding, openInterest, patterns,
        stochastic, adx, ichimoku
      } = data;
      let score = 0;
      let confidence = 0;
      let reasons = [];
      const currentRSI = rsi[rsi.length - 1];
      const currentMACD = macd.histogram[macd.histogram.length - 1];
      const prevMACD = macd.histogram[macd.histogram.length - 2];
      const currentPrice = closes[closes.length - 1];
      const bbUpper = bb.upper[bb.upper.length - 1];
      const bbLower = bb.lower[bb.lower.length - 1];
      const bbMiddle = bb.middle[bb.middle.length - 1];
      const stochK = stochastic.k[stochastic.k.length - 1];
      const stochD = stochastic.d[stochastic.d.length - 1];
      const adxValue = adx.adx[adx.adx.length - 1];
      const plusDI = adx.plusDI[adx.plusDI.length - 1];
      const minusDI = adx.minusDI[adx.minusDI.length - 1];
      const ichiSpanA = ichimoku.spanA[ichimoku.spanA.length - 1];
      const ichiSpanB = ichimoku.spanB[ichimoku.spanB.length - 1];
      const ichiConversion = ichimoku.conversionLine[ichimoku.conversionLine.length - 1];
      const ichiBase = ichimoku.baseLine[ichimoku.baseLine.length - 1];
      // RSI Analysis
      if (currentRSI !== null) {
        if (currentRSI < 30) {
          score += 2;
          confidence += 15;
          reasons.push('RSI Oversold (<30)');
        } else if (currentRSI < 40) {
          score += 1;
          confidence += 10;
          reasons.push('RSI Bullish (<40)');
        } else if (currentRSI > 70) {
          score -= 2;
          confidence += 15;
          reasons.push('RSI Overbought (>70)');
        } else if (currentRSI > 60) {
          score -= 1;
          confidence += 10;
          reasons.push('RSI Bearish (>60)');
        }
      }
      // MACD Analysis
      if (currentMACD !== null && prevMACD !== null) {
        if (currentMACD > 0 && prevMACD <= 0) {
          score += 2;
          confidence += 20;
          reasons.push('MACD Bullish Crossover');
        } else if (currentMACD < 0 && prevMACD >= 0) {
          score -= 2;
          confidence += 20;
          reasons.push('MACD Bearish Crossover');
        } else if (currentMACD > prevMACD && currentMACD > 0) {
          score += 1;
          confidence += 10;
          reasons.push('MACD Momentum Up');
        } else if (currentMACD < prevMACD && currentMACD < 0) {
          score -= 1;
          confidence += 10;
          reasons.push('MACD Momentum Down');
        }
      }
      // Bollinger Bands Analysis
      if (bbUpper !== null && bbLower !== null && bbMiddle !== null) {
        if (currentPrice <= bbLower) {
          score += 1.5;
          confidence += 12;
          reasons.push('Price at BB Lower Band');
        } else if (currentPrice >= bbUpper) {
          score -= 1.5;
          confidence += 12;
          reasons.push('Price at BB Upper Band');
        } else if (currentPrice > bbMiddle) {
          score += 0.5;
          reasons.push('Price above BB Middle');
        } else {
          score -= 0.5;
          reasons.push('Price below BB Middle');
        }
      }
      // Stochastic Analysis
      if (stochK !== null && stochD !== null) {
        if (stochK < 20 && stochD < 20 && stochK > stochD) {
          score += 1.5;
          confidence += 12;
          reasons.push('Stochastic Oversold Bullish Cross');
        } else if (stochK > 80 && stochD > 80 && stochK < stochD) {
          score -= 1.5;
          confidence += 12;
          reasons.push('Stochastic Overbought Bearish Cross');
        }
      }
      // ADX Analysis (Trend Strength)
      if (adxValue !== null && plusDI !== null && minusDI !== null) {
        if (adxValue > 25) {
          confidence += 10;
          if (plusDI > minusDI) {
            score += 1;
            reasons.push('Strong Uptrend (ADX > 25)');
          } else {
            score -= 1;
            reasons.push('Strong Downtrend (ADX > 25)');
          }
        }
      }
      // Ichimoku Analysis
      if (ichiSpanA !== null && ichiSpanB !== null && ichiConversion !== null && ichiBase !== null) {
        const cloudTop = Math.max(ichiSpanA, ichiSpanB);
        const cloudBottom = Math.min(ichiSpanA, ichiSpanB);
        if (currentPrice > cloudTop && ichiConversion > ichiBase) {
          score += 1.5;
          confidence += 15;
          reasons.push('Ichimoku Bullish (Price above cloud, Conversion above Base)');
        } else if (currentPrice < cloudBottom && ichiConversion < ichiBase) {
          score -= 1.5;
          confidence += 15;
          reasons.push('Ichimoku Bearish (Price below cloud, Conversion below Base)');
        }
      }
      // Volume Analysis
      if (volume && volume.length >= 10) {
        const avgVolume = volume.slice(-10).reduce((a, b) => a + b, 0) / 10;
        const currentVolume = volume[volume.length - 1];
        if (currentVolume > avgVolume * 1.5) {
          confidence += 15;
          reasons.push('High Volume Spike');
        }
      }
      // Funding Rate Analysis
      if (funding !== null) {
        const fundingRate = parseFloat(funding);
        if (fundingRate < -0.01) {
          score += 1;
          confidence += 8;
          reasons.push('Negative Funding (Long Reward)');
        } else if (fundingRate > 0.05) {
          score -= 1;
          confidence += 8;
          reasons.push('High Funding (Short Reward)');
        }
      }
      // Candlestick Pattern Analysis
      patterns.forEach(pattern => {
        if (['Hammer', 'Bullish Engulfing', 'Morning Star', 'Dragonfly Doji'].includes(pattern)) {
          score += 1;
          confidence += 10;
          reasons.push(`Bullish Pattern: ${pattern}`);
        } else if (['Shooting Star', 'Bearish Engulfing', 'Evening Star', 'Gravestone Doji'].includes(pattern)) {
          score -= 1;
          confidence += 10;
          reasons.push(`Bearish Pattern: ${pattern}`);
        }
      });
      // Market Adaptation: Adjust confidence based on market conditions
      // If multiple indicators agree, increase confidence
      const bullishIndicators = reasons.filter(r => r.includes('Bullish') || r.includes('Uptrend') || r.includes('Oversold')).length;
      const bearishIndicators = reasons.filter(r => r.includes('Bearish') || r.includes('Downtrend') || r.includes('Overbought')).length;
      if (bullishIndicators > 2) {
        confidence += 10;
        reasons.push('Multiple Bullish Confirmations');
      } else if (bearishIndicators > 2) {
        confidence += 10;
        reasons.push('Multiple Bearish Confirmations');
      }

      // Normalize confidence to 0-100 range before calculating strength
      confidence = Math.min(100, Math.max(0, confidence));

      // Determine final signal
      let signal = 'NEUTRAL';
      let strength = 0;

      // Strength is now directly tied to the absolute score, but capped at 5
      // Confidence is a separate measure of reliability
      if (score >= 3) {
        signal = 'LONG';
        strength = Math.min(5, Math.ceil(score));
      } else if (score <= -3) {
        signal = 'SHORT';
        strength = Math.min(5, Math.ceil(Math.abs(score)));
      } else if (Math.abs(score) >= 1.5) {
        signal = score > 0 ? 'WEAK_LONG' : 'WEAK_SHORT';
        strength = 1;
      }

      return {
        signal,
        strength,
        confidence,
        score: score.toFixed(2),
        reasons: reasons.slice(0, 5) // Limit to top 5 reasons
      };
    };

    // API Functions with Enhanced Data Quality Checks
    const fetchWithRetry = async (url, maxRetries = 3) => {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP ${response.status}`);
          return await response.json();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          await sleep(1000 * (i + 1));
        }
      }
    };
    const getActiveSymbols = async () => {
      const exchangeInfo = await fetchWithRetry(API_ENDPOINTS.exchangeInfo);
      // Veri Kalitesi Kontrolleri: Sadece aktif ve USDT ile işlem gören perpetual sözleşmeler
      return exchangeInfo.symbols
        .filter(s => 
          s.contractType === 'PERPETUAL' && 
          s.quoteAsset === 'USDT' && 
          s.status === 'TRADING'
        )
        .map(s => s.symbol);
    };
    const get24hrStats = async () => {
      const data = await fetchWithRetry(API_ENDPOINTS.ticker24hr);
      const stats = {};
      data.forEach(ticker => {
        // Veri Kalitesi Kontrolleri: Geçersiz verileri filtrele
        if (ticker && ticker.symbol) {
            stats[ticker.symbol] = {
            priceChange: parseFloat(ticker.priceChange) || 0,
            priceChangePercent: parseFloat(ticker.priceChangePercent) || 0,
            lastPrice: parseFloat(ticker.lastPrice) || 0,
            volume: parseFloat(ticker.volume) || 0,
            quoteVolume: parseFloat(ticker.quoteVolume) || 0,
            highPrice: parseFloat(ticker.highPrice) || 0,
            lowPrice: parseFloat(ticker.lowPrice) || 0,
            openPrice: parseFloat(ticker.openPrice) || 0
          };
        }
      });
      return stats;
    };
    const getKlines = async (symbol, interval, limit) => {
      const url = `${API_ENDPOINTS.klines}?symbol=${symbol}&interval=${interval}&limit=${limit}`;
      const data = await fetchWithRetry(url);
       // Veri Kalitesi Kontrolleri: Kline verisinin formatını kontrol et
       if (!Array.isArray(data)) {
        console.error(`Invalid kline data for ${symbol}`);
        return []; // Boş array döndürerek hatayı yönet
      }
      return data;
    };
    const getFundingRate = async (symbol) => {
      try {
        const url = `${API_ENDPOINTS.premiumIndex}?symbol=${symbol}`;
        const data = await fetchWithRetry(url);
        // Veri Kalitesi Kontrolleri: Funding rate verisinin formatını kontrol et
        if (data && Array.isArray(data) && data.length > 0 && data[0].lastFundingRate !== undefined) {
           return parseFloat(data[0].lastFundingRate);
        } else if (data && data.lastFundingRate !== undefined) {
           return parseFloat(data.lastFundingRate);
        }
        return null;
      } catch (error) {
        console.warn(`Funding rate fetch failed for ${symbol}:`, error.message);
        return null; // Hata durumunda null döndür
      }
    };
    const getOpenInterest = async (symbol) => {
      try {
        const url = `${API_ENDPOINTS.openInterest}?symbol=${symbol}`;
        const data = await fetchWithRetry(url);
        // Veri Kalitesi Kontrolleri: Open interest verisinin formatını kontrol et
        if (data && data.openInterest !== undefined) {
          return parseFloat(data.openInterest);
        }
        return null;
      } catch (error) {
        console.warn(`Open interest fetch failed for ${symbol}:`, error.message);
        return null; // Hata durumunda null döndür
      }
    };
    // Main Scanning Function
    const performAdvancedScan = async () => {
      const settings = {
        topN: parseInt(document.getElementById('topN').value),
        interval: document.getElementById('interval').value,
        limit: parseInt(document.getElementById('limit').value),
        minSignalStrength: parseInt(document.getElementById('minSignalStrength').value),
        minVolatility: parseFloat(document.getElementById('minVolatility').value)
      };
      updateProgress(0, 'Sembolleri alınıyor...');
      try {
        // Get symbols and 24hr stats
        const [symbols, stats24hr] = await Promise.all([
          getActiveSymbols(),
          get24hrStats()
        ]);
        updateProgress(10, 'Volatilite analizi yapılıyor...');
        // Calculate volatility and filter symbols
        const symbolsWithVolatility = symbols
          .filter(symbol => stats24hr[symbol]) // Veri Kalitesi Kontrolleri: Sadece verisi olan sembolleri işle
          .map(symbol => {
            const stats = stats24hr[symbol];
            // Veri Kalitesi Kontrolleri: Sıfıra bölme hatasını önlemek için kontrol
            const lastPrice = stats.lastPrice;
            const highPrice = stats.highPrice;
            const lowPrice = stats.lowPrice;
            const volatility = (lastPrice > 0) ? ((highPrice - lowPrice) / lastPrice) * 100 : 0;
            return {
              symbol,
              volatility,
              priceChangePercent: stats.priceChangePercent,
              lastPrice: stats.lastPrice,
              volume: stats.volume,
              quoteVolume: stats.quoteVolume
            };
          })
          .filter(item => item.volatility >= settings.minVolatility)
          .sort((a, b) => b.volatility - a.volatility)
          .slice(0, settings.topN);
        updateProgress(20, `${symbolsWithVolatility.length} sembol analiz ediliyor...`);
        const results = [];
        const batchSize = 5; // Process in smaller batches
        for (let i = 0; i < symbolsWithVolatility.length; i += batchSize) {
          const batch = symbolsWithVolatility.slice(i, i + batchSize);
          const batchPromises = batch.map(async (item, index) => {
            try {
              // Get klines data
              const klines = await getKlines(item.symbol, settings.interval, settings.limit);
              // Veri Kalitesi Kontrolleri: Yeterli kline verisi var mı?
              if (klines.length < Math.min(settings.limit, 50)) { // En az 50 mum iste
                 console.warn(`Insufficient kline data for ${item.symbol}. Got ${klines.length} candles.`);
                 return null; // Yetersiz veri varsa atla
              }
              const opens = klines.map(k => parseFloat(k[1]));
              const highs = klines.map(k => parseFloat(k[2]));
              const lows = klines.map(k => parseFloat(k[3]));
              const closes = klines.map(k => parseFloat(k[4]));
              const volumes = klines.map(k => parseFloat(k[5]));
              // Calculate technical indicators
              const rsi = calculateRSI(closes);
              const macd = calculateMACD(closes);
              const bb = calculateBollingerBands(closes);
              const atr = calculateATR(highs, lows, closes);
              const stochastic = calculateStochastic(highs, lows, closes);
              const adx = calculateADX(highs, lows, closes);
              const ichimoku = calculateIchimoku(highs, lows, closes);
              const patterns = detectCandlestickPatterns(opens, highs, lows, closes, volumes);
              // Get additional data
              const [funding, openInterest] = await Promise.all([
                getFundingRate(item.symbol),
                getOpenInterest(item.symbol)
              ]);
              // Generate advanced signal
              const signalData = generateAdvancedSignal({
                rsi, macd, bb, atr, closes, volume: volumes,
                funding, openInterest, patterns,
                stochastic, adx, ichimoku
              });
              // Calculate additional metrics
              const atrPercent = atr[atr.length - 1] ? (atr[atr.length - 1] / closes[closes.length - 1]) * 100 : null;
              const currentPrice = closes[closes.length - 1];
              const bbPosition = bb.upper[bb.upper.length - 1] && bb.lower[bb.lower.length - 1] 
                ? ((currentPrice - bb.lower[bb.lower.length - 1]) / (bb.upper[bb.upper.length - 1] - bb.lower[bb.lower.length - 1])) * 100 
                : null;
              return {
                symbol: item.symbol,
                volatility: item.volatility,
                lastPrice: item.lastPrice,
                priceChangePercent: item.priceChangePercent,
                volume: item.volume,
                quoteVolume: item.quoteVolume,
                rsi: rsi[rsi.length - 1],
                macd: macd.histogram[macd.histogram.length - 1],
                bbPosition,
                atrPercent,
                funding: funding ? funding * 100 : null,
                openInterest,
                patterns,
                signal: signalData,
                technicalData: {
                  opens, highs, lows, closes, volumes,
                  rsi, macd, bb, atr, stochastic, adx, ichimoku
                }
              };
            } catch (error) {
              console.error(`Error analyzing ${item.symbol}:`, error);
              return null; // Hata durumunda null döndür
            }
          });
          const batchResults = await Promise.all(batchPromises);
          results.push(...batchResults.filter(Boolean)); // null değerleri filtrele
          const progress = 20 + ((i + batchSize) / symbolsWithVolatility.length) * 70;
          updateProgress(progress, `Analiz ediliyor: ${Math.min(i + batchSize, symbolsWithVolatility.length)}/${symbolsWithVolatility.length}`);
          // Rate limiting
          await sleep(200);
        }
        // Filter by signal strength
        const filteredResults = results.filter(result => 
          result.signal && result.signal.strength >= settings.minSignalStrength
        );
        // Sıralama Kriteri: En yüksek güven yüzdesine göre (ve ardından volatiliteye göre)
        filteredResults.sort((a, b) => {
          // Önce güven yüzdesine göre azalan sıralama
          if (b.signal.confidence !== a.signal.confidence) {
            return b.signal.confidence - a.signal.confidence;
          }
          // Güven yüzdesi aynıysa, sinyal gücüne göre azalan sıralama
          if (b.signal.strength !== a.signal.strength) {
            return b.signal.strength - a.signal.strength;
          }
          // Her ikisi de aynıysa volatiliteye göre azalan sıralama
          return b.volatility - a.volatility;
        });
        currentData = filteredResults;
        updateProgress(100, `Analiz tamamlandı: ${filteredResults.length} sinyal bulundu`);
        renderResults(filteredResults);
        updateLastUpdateTime();
      } catch (error) {
        console.error('Scan error:', error);
        updateProgress(0, `Hata: ${error.message}`);
      }
    };
    // UI Update Functions
    const updateProgress = (percent, status) => {
      const container = document.getElementById('progressContainer');
      const fill = document.getElementById('progressFill');
      const statusEl = document.getElementById('progressStatus');
      const percentEl = document.getElementById('progressPercent');
      if (percent > 0) {
        container.style.display = 'block';
      } else if (percent === 100) {
        setTimeout(() => {
          container.style.display = 'none';
        }, 2000);
      }
      fill.style.width = `${percent}%`;
      statusEl.textContent = status;
      percentEl.textContent = `${Math.round(percent)}%`;
    };
    const updateLastUpdateTime = () => {
      const now = new Date();
      const timeString = now.toLocaleTimeString('tr-TR');
      document.getElementById('lastUpdate').textContent = timeString;
    };
    const renderResults = (results) => {
      const tbody = document.getElementById('dataTableBody');
      if (results.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="13" class="text-center" style="padding: 40px;">
              <div style="color: var(--text-muted);">
                Belirlenen kriterlere uygun sinyal bulunamadı.<br>
                Filtreleri gevşeterek tekrar deneyin.
              </div>
            </td>
          </tr>
        `;
        return;
      }
      tbody.innerHTML = '';
      results.forEach((item, index) => {
        const row = document.createElement('tr');
        row.className = 'table-row';
        row.dataset.symbol = item.symbol;
        // CSS sınıfı için sinyal adını küçük harfe çevir ve alt çizgiyi tire ile değiştir
        const signalClass = item.signal.signal.toLowerCase().replace('_', '-');
        const strengthStars = '★'.repeat(item.signal.strength);
        row.innerHTML = `
          <td>
            <div class="symbol-cell">${item.symbol}</div>
            <div class="symbol-meta">${item.patterns.slice(0, 2).join(', ') || 'No patterns'}</div>
          </td>
          <td>${fmt(item.volatility, 1)}%</td>
          <td class="font-mono">${fmt(item.lastPrice, 4)}</td>
          <td class="${item.priceChangePercent >= 0 ? 'text-success' : 'text-danger'}">
            ${item.priceChangePercent >= 0 ? '+' : ''}${fmt(item.priceChangePercent, 2)}%
          </td>
          <td>${fmt(item.rsi, 1)}</td>
          <td>${fmt(item.macd, 4)}</td>
          <td>${item.bbPosition ? fmt(item.bbPosition, 0) + '%' : '—'}</td>
          <td>${fmt(item.volume / 1000000, 1)}M</td>
          <td>${fmt(item.atrPercent, 2)}%</td>
          <td class="${item.funding && item.funding < 0 ? 'text-success' : 'text-warning'}">
            ${item.funding ? fmt(item.funding, 3) + '%' : '—'}
          </td>
          <td>${item.openInterest ? fmt(item.openInterest / 1000000, 1) + 'M' : '—'}</td>
          <td>
            <div class="signal-tag ${signalClass}">
              ${item.signal.signal.replace('_', ' ')}
            </div>
          </td>
          <td>
            <span style="color: var(--warning)">${strengthStars}</span>
            <div style="font-size: 10px; color: var(--text-muted);">${item.signal.confidence}%</div>
          </td>
        `;
        row.addEventListener('click', () => selectSymbol(item));
        tbody.appendChild(row);
      });
    };
    const selectSymbol = (data) => {
      // Remove previous selection
      document.querySelectorAll('.table-row.selected').forEach(row => {
        row.classList.remove('selected');
      });
      // Add selection to clicked row
      const row = document.querySelector(`[data-symbol="${data.symbol}"]`);
      if (row) row.classList.add('selected');
      selectedSymbol = data;
      updateChart(data);
      updateAnalysis(data);
    };
    const updateChart = (data) => {
      const ctx = document.getElementById('priceChart');
      const { closes, rsi, macd, bb } = data.technicalData;
      document.getElementById('chartTitle').textContent = `${data.symbol}`;
      document.getElementById('chartMeta').textContent = 
        `${fmt(data.lastPrice, 4)} USDT • ${data.priceChangePercent >= 0 ? '+' : ''}${fmt(data.priceChangePercent, 2)}%`;
      const labels = closes.map((_, i) => i);
      if (priceChart) {
        priceChart.destroy();
      }
      priceChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'Fiyat',
              data: closes,
              borderColor: '#3b82f6',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.1,
              pointRadius: 0
            },
            {
              label: 'BB Upper',
              data: bb.upper,
              borderColor: 'rgba(239, 68, 68, 0.5)',
              borderWidth: 1,
              fill: false,
              pointRadius: 0,
              borderDash: [5, 5]
            },
            {
              label: 'BB Middle',
              data: bb.middle,
              borderColor: 'rgba(156, 163, 175, 0.7)',
              borderWidth: 1,
              fill: false,
              pointRadius: 0
            },
            {
              label: 'BB Lower',
              data: bb.lower,
              borderColor: 'rgba(16, 185, 129, 0.5)',
              borderWidth: 1,
              fill: false,
              pointRadius: 0,
              borderDash: [5, 5]
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#d1d5db',
                font: { size: 11 }
              }
            }
          },
          scales: {
            x: {
              display: false
            },
            y: {
              position: 'right',
              ticks: {
                color: '#9ca3af',
                font: { size: 10 }
              },
              grid: {
                color: 'rgba(75, 85, 99, 0.2)'
              }
            }
          },
          elements: {
            line: {
              tension: 0.1
            }
          }
        }
      });
    };
    const updateAnalysis = (data) => {
      const analysisEl = document.getElementById('analysisContent');
      const candleEl = document.getElementById('candlePatterns');
      const signal = data.signal;
      const signalColor = signal.signal.includes('LONG') ? 'var(--success)' : 
                         signal.signal.includes('SHORT') ? 'var(--danger)' : 'var(--text-muted)';
      analysisEl.innerHTML = `
        <div style="margin-bottom: 12px;">
          <strong style="color: ${signalColor};">${signal.signal.replace('_', ' ')}</strong>
          <span style="color: var(--text-muted);"> • Güven: ${signal.confidence}%</span>
        </div>
        <div style="font-size: 12px; line-height: 1.4;">
          <div><strong>RSI:</strong> ${fmt(data.rsi, 1)} ${data.rsi < 30 ? '(Oversold)' : data.rsi > 70 ? '(Overbought)' : ''}</div>
          <div><strong>MACD:</strong> ${fmt(data.macd, 4)} ${data.macd > 0 ? '(Bullish)' : '(Bearish)'}</div>
          <div><strong>BB Pozisyonu:</strong> ${data.bbPosition ? fmt(data.bbPosition, 0) + '%' : '—'}</div>
          <div><strong>ATR:</strong> ${fmt(data.atrPercent, 2)}% (Volatilite)</div>
          <div><strong>Funding:</strong> ${data.funding ? fmt(data.funding, 3) + '%' : '—'}</div>
        </div>
        <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid var(--border); font-size: 11px;">
          <strong>Analiz Nedenleri:</strong><br>
          ${signal.reasons.join('<br>') || 'Neden bulunamadı'}
        </div>
      `;
      candleEl.innerHTML = data.patterns.length > 0 
        ? data.patterns.map(pattern => `<span style="color: var(--accent-cyan);">${pattern}</span>`).join(' • ')
        : '<span style="color: var(--text-muted);">Belirgin formasyon yok</span>';
    };
    const exportToCSV = () => {
      if (currentData.length === 0) {
        alert('Dışa aktarılacak veri bulunamadı. Önce tarama yapın.');
        return;
      }
      const headers = [
        'Symbol', 'Signal', 'Strength', 'Confidence', 'Price', 'Change%', 
        'Volatility%', 'RSI', 'MACD', 'BB_Position%', 'ATR%', 'Funding%',
        'Volume', 'OpenInterest', 'Patterns', 'Reasons'
      ];
      const rows = currentData.map(item => [
        item.symbol,
        item.signal.signal,
        item.signal.strength,
        item.signal.confidence,
        item.lastPrice,
        item.priceChangePercent,
        item.volatility,
        fmt(item.rsi, 2),
        fmt(item.macd, 4),
        item.bbPosition ? fmt(item.bbPosition, 1) : '',
        fmt(item.atrPercent, 2),
        item.funding ? fmt(item.funding, 3) : '',
        Math.round(item.volume),
        item.openInterest || '',
        item.patterns.join(';'),
        item.signal.reasons.join(';')
      ]);
      const csvContent = [headers, ...rows]
        .map(row => row.map(cell => `"${cell}"`).join(','))
        .join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
      link.download = `binance_futures_scan_${timestamp}.csv`;
      link.href = URL.createObjectURL(blob);
      link.click();
    };
    // Event Listeners
    document.getElementById('scanBtn').addEventListener('click', async () => {
      if (isScanning) return;
      const btn = document.getElementById('scanBtn');
      const originalText = btn.innerHTML;
      btn.innerHTML = '<div class="loading"></div> <span>Taranıyor...</span>';
      btn.disabled = true;
      isScanning = true;
      try {
        await performAdvancedScan();
      } catch (error) {
        console.error('Scan failed:', error);
        updateProgress(0, `Tarama hatası: ${error.message}`);
      } finally {
        btn.innerHTML = originalText;
        btn.disabled = false;
        isScanning = false;
      }
    });
    document.getElementById('stopBtn').addEventListener('click', () => {
      if (scanInterval) {
        clearInterval(scanInterval);
        scanInterval = null;
      }
      updateProgress(0, 'Otomatik tarama durduruldu');
    });
    document.getElementById('exportBtn').addEventListener('click', exportToCSV);
    document.getElementById('alertsBtn').addEventListener('click', () => {
      alert('Alarm sistemi geliştirme aşamasında. Yakında eklenecek!');
    });
    // Auto-refresh setup
    const setupAutoRefresh = () => {
      const refreshInput = document.getElementById('refreshInterval');
      const startAutoRefresh = () => {
        if (scanInterval) clearInterval(scanInterval);
        const interval = Math.max(15, parseInt(refreshInput.value)) * 1000;
        scanInterval = setInterval(() => {
          if (!isScanning && currentData.length > 0) {
            performAdvancedScan();
          }
        }, interval);
      };
      refreshInput.addEventListener('change', () => {
        if (scanInterval) {
          startAutoRefresh();
        }
      });
      // Start auto-refresh after first manual scan
      document.getElementById('scanBtn').addEventListener('click', () => {
        setTimeout(startAutoRefresh, 5000);
      }, { once: true });
    };
    // Initialize
    setupAutoRefresh();
    // Initial message
    console.log('🚀 Gelişmiş Binance Futures Tarayıcı Pro hazır!');
    console.log('📊 Özellikler: RSI, MACD, Bollinger Bands, ATR, Stochastic, ADX, Ichimoku, Mum formasyonları, Funding oranları');
    console.log('🎯 AI destekli sinyal üretimi aktif');
  </script>
</body>
</html>